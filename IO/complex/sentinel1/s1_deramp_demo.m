function s1_deramp_demo( manifest_safe_filename )
%S1_DERAMP_DEMO Implementation of ESA TOPSAR azimuth deramp for Sentinal-1
%
% Reference: Definition of the TOPS SLC deramping function for products
% generated by the S-1 IPF, COPE-GSEG-EOPG-TN-14-0025
%
% Written by: Wade Schwartzkopf, NGA Research
%
% //////////////////////////////////////////
% /// CLASSIFICATION: UNCLASSIFIED       ///
% //////////////////////////////////////////

%% Constants
xp = xpath();
SECONDS_IN_A_DAY = 24*60*60;
SYMMETRY=[0 0 1];
SP = 1; % Swath and polarization
BURST = 1; % Which burst in swath and polarization SP do we want to examine?

%% Open files
manifest_domnode = read_xml(manifest_safe_filename);
files = s1manifest_files(manifest_domnode);
readerobj=cell(1,numel(files));
for i=1:numel(files) % File for each swath and polarization
    basepathname = fileparts(manifest_safe_filename);
    datafilename = files(i).data;
    if i==SP
        readerobj = open_ctiff_reader_noxml(fullfile(basepathname,datafilename),SYMMETRY);
    end
    domnode{i} = read_xml(fullfile(fileparts(manifest_safe_filename), files(i).product));
    if ~strcmpi(char(xp.evaluate('product/adsHeader/mode',domnode{i})),'IW')
        error('S1_DERAMP_DEMO:NOT_IW_MODE','This function only works for Sentinel 1 IW mode data.');
    end
    [start_s(i), start_frac(i)] = datenum_w_frac(char(xp.evaluate(...
        'product/generalAnnotation/downlinkInformationList/downlinkInformation/firstLineSensingTime',domnode{i})));
end
% Allow for testing with the sample XML data in ESA document
% SP = 1;
% domnode{SP}=read_xml(manifest_safe_filename);
% [start_s, start_frac] = datenum_w_frac(char(xp.evaluate(...
%     'product/swathTiming/burstList/burst[1]/azimuthTime',domnode{SP})));


%% Extract required variables from XML (constant for chosen swath and polarization)
% The main variables are defined in table 1 of document
k_psi = str2double(char(xp.evaluate(...
    'product/generalAnnotation/productInformation/azimuthSteeringRate',domnode{SP})));
k_psi = k_psi*pi/180; % Convert from degrees/sec into radians/sec
num_dc_estimates_az=str2double(xp.evaluate(...
    'count(product/dopplerCentroid/dcEstimateList/dcEstimate)',domnode{SP}));
for i = 1:num_dc_estimates_az
    [dc_t_s, dc_t_frac] = datenum_w_frac(char(xp.evaluate(...
        ['product/dopplerCentroid/dcEstimateList/dcEstimate[' num2str(i) ']/azimuthTime'],...
        domnode{SP})));
    dc_t(i) = round((dc_t_s-start_s(SP))*SECONDS_IN_A_DAY) + ... % Convert from days to secs
        (dc_t_frac-start_frac(SP)); % Handle fractional seconds
    dc_t0(i) = str2double(xp.evaluate(...
        ['product/dopplerCentroid/dcEstimateList/dcEstimate[' num2str(i) ']/t0'],...
        domnode{SP}));
    f_eta_c_poly{i} = str2num(xp.evaluate(...
        ['product/dopplerCentroid/dcEstimateList/dcEstimate[' num2str(i) ']/dataDcPolynomial'],...
        domnode{SP}));
end
num_azfm_rates=str2double(xp.evaluate(...
    'count(product/generalAnnotation/azimuthFmRateList/azimuthFmRate)',...
    domnode{SP}));
for i = 1:num_azfm_rates
    [az_t_s, az_t_frac] = datenum_w_frac(char(xp.evaluate(...
        ['product/generalAnnotation/azimuthFmRateList/azimuthFmRate[' ...
        num2str(i) ']/azimuthTime'],domnode{SP})));
    az_rate_t(i) = round((az_t_s-start_s(SP))*SECONDS_IN_A_DAY) + ... % Convert from days to secs
        (az_t_frac-start_frac(SP)); % Handle fractional seconds
    az_t0(i) = str2double(xp.evaluate(...
        ['product/generalAnnotation/azimuthFmRateList/azimuthFmRate[' ...
        num2str(i) ']/t0'],domnode{SP})).';
    k_a_poly{i} = str2num(xp.evaluate(...
        ['product/generalAnnotation/azimuthFmRateList/azimuthFmRate[' ...
        num2str(i) ']/azimuthFmRatePolynomial'],domnode{SP})).';
end
f_c = str2double(char(xp.evaluate(...
    'product/generalAnnotation/productInformation/radarFrequency',domnode{SP})));
num_orbit=str2double(xp.evaluate(...
    'count(product/generalAnnotation/orbitList/orbit)',domnode{SP}));
for i = 1:num_orbit
    [orbit_s, orbit_frac] = datenum_w_frac(char(xp.evaluate(...
        ['product/generalAnnotation/orbitList/orbit[' num2str(i) ']/time'],...
        domnode{SP})));
    orbit_time(i) = round((orbit_s-start_s(SP))*SECONDS_IN_A_DAY) + ... % Convert from days to secs
        (orbit_frac-start_frac(SP)); % Handle fractional seconds

    orbit_vel(i) = norm([str2double(char(xp.evaluate(...
        ['product/generalAnnotation/orbitList/orbit[' num2str(i) ']/velocity/x'],domnode{SP}))) ...
        str2double(char(xp.evaluate(...
        ['product/generalAnnotation/orbitList/orbit[' num2str(i) ']/velocity/y'],domnode{SP}))) ...
        str2double(char(xp.evaluate(...
        ['product/generalAnnotation/orbitList/orbit[' num2str(i) ']/velocity/z'],domnode{SP})))]);
end
ORBIT_POLYORDER=2;
v_s_poly  = polyfit(orbit_time, orbit_vel, ORBIT_POLYORDER); % Compute orbit polynomial
num_lines_burst = str2double(char(xp.evaluate(...
    'product/swathTiming/linesPerBurst',domnode{SP})));
num_samples = str2double(char(xp.evaluate(...
    'product/swathTiming/samplesPerBurst',domnode{SP})));
delta_t_s = str2double(char(xp.evaluate(...
    'product/imageAnnotation/imageInformation/azimuthTimeInterval',domnode{SP})));
delta_tau_s = 1/str2double(char(xp.evaluate(...
    'product/generalAnnotation/productInformation/rangeSamplingRate',domnode{SP})));
tau_0 = str2double(char(xp.evaluate(...
    'product/imageAnnotation/imageInformation/slantRangeTime',domnode{SP})));
eta = (-num_lines_burst*delta_t_s/2) + (0:(num_lines_burst-1))*delta_t_s;

%% Compute all burst-dependent variables required for building deramp phase function
num_bursts=str2double(xp.evaluate(...
    'count(product/swathTiming/burstList/burst)',domnode{SP}));
for i = 1:num_bursts
    [burst_s, burst_frac] = datenum_w_frac(char(xp.evaluate(...
        ['product/swathTiming/burstList/burst[' num2str(i) ']/azimuthTime'],domnode{SP})));
    eta_start = round((burst_s-start_s(SP)) * SECONDS_IN_A_DAY) + ... % Convert from days to secs
        (burst_frac-start_frac(SP)); % Handle fractional seconds
    eta_mid(i) = eta_start + (delta_t_s * num_lines_burst/2); % Equ. 9
    v_s(i) = polyval(v_s_poly,eta_mid(i));
    % Compute Doppler rate as introduced by antenna steering, k_s (section 6.2)
    k_s(i) = (2 * v_s(i) / SPEED_OF_LIGHT) * f_c * k_psi; % Equ. 4
    % Compute FM Doppler Rate, k_a (section 6.3)
    % Pick azimuth time closest to eta_mid
    [~,az_rate_ind]=min(abs(az_rate_t-eta_mid(i)));
    tau = tau_0 + delta_tau_s * (0:(num_samples-1)); % Range time for each sample
    tau_rel = tau - az_t0(az_rate_ind); % Relative range time for each sample
    k_a{i} = polyval(k_a_poly{az_rate_ind}(end:-1:1), tau_rel); % Equ. 11
    % Compute Doppler Centroid Rate, k_t (section 6.4)
    k_t{i} = (k_a{i} * k_s(i))./(k_a{i} - k_s(i)); % Equ. 2
    % Compute Doppler Centroid Frequency, f_eta_c (section 6.5)
    [~,dc_rate_ind]=min(abs(dc_t-eta_mid(i)));
    tau_rel = tau - dc_t0(dc_rate_ind); % Relative range time for each sample
    f_eta_c{i} = polyval(f_eta_c_poly{dc_rate_ind}(end:-1:1), tau_rel); % Equ. 13
    % Compute Reference zero-Doppler Azimuth Time, eta_ref (section 6.6)
    eta_c = - f_eta_c{i}./k_a{i}; % Equ. 7
    eta_ref{i} = eta_c - eta_c(1); % Equ. 6
end

%% Read data and apply phase function
% Get valid bounds of burst from metadata
for i = 1:num_bursts
    firstSample{i} = str2num(char(xp.evaluate(...
        ['product/swathTiming/burstList/burst[' num2str(i) ']/firstValidSample'],domnode{SP})));
    lastSample{i} = str2num(char(xp.evaluate(...
        ['product/swathTiming/burstList/burst[' num2str(i) ']/lastValidSample'],domnode{SP})));
    first_col(i) = find((firstSample{i}>=0)&(lastSample{i}>0),1,'first');
    last_col(i) = find((firstSample{i}>=0)&(lastSample{i}>0),1,'last');
    first_row(i) = max(firstSample{i}) + 1; % +1 since we assume zero indexed
    last_row(i) = min(lastSample{i}((firstSample{i}>=0)&(lastSample{i}>0))) + 1;
end
% % Temp for testing full image
% first_row(:) = 1;
% first_col(:) = 1;
% last_row(:) = num_samples;
% last_col(:) = num_lines_burst;
% Read only valid pixels from a single burst
cdata = double(readerobj.read_chip(...
    num_lines_burst*(BURST-1) + [first_col(BURST) last_col(BURST)], ...
    [first_row(BURST) last_row(BURST)])); % Could be large and slow
readerobj.close(); % Don't need reader object anymore
% Distribute require values to arrays the same size as our image so we can
% do easy element-wise math
[eta_grid, eta_ref_grid] = ndgrid(eta(first_col(BURST):last_col(BURST)), ...
    eta_ref{BURST}(first_row(BURST):last_row(BURST)));
eta_arg = eta_grid-eta_ref_grid;
k_t_grid = repmat(k_t{BURST}(first_row(BURST):last_row(BURST)),numel(first_col(BURST):last_col(BURST)),1);
f_eta_c_grid = repmat(f_eta_c{BURST}(first_row(BURST):last_row(BURST)),numel(first_col(BURST):last_col(BURST)),1);
% Deramp (and demodulate) burst
deramp_phase = -k_t_grid.*(eta_arg.^2)/2; % Equ. 14
demod_phase = -f_eta_c_grid.*eta_arg; % Equ. 8
deramped_cdata = cdata.*exp(2*pi*1i*(deramp_phase + demod_phase)); % Equ. 8

%% Display results
%Deramped/demodded spatial frequency data should be compact and centered.
if ~isempty(ver('signal'))
    % Show spectrograms like in figure 2 of document.
    nfft = 32;  % Seems to work well for these datasets
    azimuth_line = 1; % Near range
    [yy,f,t] = spectrogram(cdata(:,azimuth_line), ...
        hamming(nfft), nfft-1, nfft, 1/delta_t_s);
    yy = fftshift(yy,1);
    f = fftshift(f);
    f(f>=1/(2*delta_t_s)) = f(f>=1/(2*delta_t_s)) - 1/delta_t_s;
    figure('Name', 'Spectrogram without deramp');
    imagesc(t,f,abs(yy)); axis xy;
    title('TOPS SLC Spectrogram - near range');
    xlabel('Burst time (s)');
    ylabel('Ambiguous Doppler frequency (Hz)');
    [yy,f,t] = spectrogram(deramped_cdata(:,azimuth_line), ...
        hamming(nfft), nfft-1, nfft, 1/delta_t_s);
    yy = fftshift(yy,1);
    f = fftshift(f);
    f(f>=1/(2*delta_t_s)) = f(f>=1/(2*delta_t_s)) - 1/delta_t_s;
    figure('Name', 'Spectrogram with deramp');
    imagesc(t,f,abs(yy)); axis xy;
    title('TOPS SLC Spectrogram with azimuth deramp - near range');
    xlabel('Burst time (s)');
    ylabel('Relative Doppler frequency (Hz)');
end
% FFT burst and display result
fh = figure('Name', '2D FFT without deramp');
imshow(densityremap(fftshift(fft2(cdata.'))));
set(gca,'OuterPosition',[0 0 1 1],'DataAspectRatio',[size(cdata,1) size(cdata,2), 1]); % Square up figure
ss = get(groot,'ScreenSize');
square_size = min(ss(4),ss(3)/2) - 50;
set(fh,'Position',[(ss(3)-2*square_size)/4 (ss(4)-square_size)/2 square_size square_size]); % Left half of screen
% FFT deramped burst and display result
fh = figure('Name', '2D FFT with deramp');
imshow(densityremap(fftshift(fft2(double(deramped_cdata.')))));
set(gca,'OuterPosition',[0 0 1 1],'DataAspectRatio',[size(cdata,1) size(cdata,2), 1]); % Square up figure
set(fh,'Position',[square_size + 3*(ss(3)-2*square_size)/4 (ss(4)-square_size)/2 square_size square_size]); % Right half of screen

end


% MATLAB's datenum function won't handle precise times down under a
% millisecond, because 1) It won't accept a format with more than 3 .FFF in
% the string description of the date format and 2) the resulting serial
% date number is stored in days from 00-JAN-0000 and just doesn't have
% enough bits to handle fractional seconds to the level we want.  Here we
% handle the fractional seconds separately so we can read date with the
% precision we need.
function [datenum_s, datenum_frac] = datenum_w_frac(datestring)
    datenum_s = datenum(datestring,'yyyy-mm-ddTHH:MM:SS');
    datenum_frac = str2double(regexp(datestring,'\.\d*','match'));
    if isnan(datenum_frac), datenum_frac = 0; end;
end

% //////////////////////////////////////////
% /// CLASSIFICATION: UNCLASSIFIED       ///
% //////////////////////////////////////////